<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
			  <section>
			    <h3>General Recursion</h3>

			    <p>PFPL chapters 19 and 20 | TAPL chapter 11.11</p>

			    <p class="fragment"><i>Key idea:</i>
			    Exchange <span style="border: solid #8080ff
			    2px">totality</span>
			    for <span style="border: solid #ff8080
			    2px">universality</span></p>

			    <p class="fragment"><i>Increase <span style="border: solid #ff8080
			    2px">expressive
				  power</span> of programs at the expense of
				<span style="border: solid #8080ff
					     2px">termination
					     guarantee</span></i></p>

			  </section>
			  <section>
			    <h3>Surveying the Language Landscape</h3>

			    <p class="fragment">Languages we've explored thus far:</p>

			    <table style="font-size: 50%">
			      <tr class="fragment">
				<th>Name</th>
				<th>Properties</th>
			      </tr>
			      <tr class="fragment">
				<td><b>System T</b><br />(PFPL §9)</td>
				<td>natural numbers, higher-order
				functions, products, sums, booleans,
				enumerations, options, totality, type
				safety</td>
			      </tr>
			      <tr class="fragment">
				<td><b>System M</b><br />(PFPL §15)</td>
				<td><i>System T plus</i>
				(co-)inductive types <i>(via recursion on
				    types)</i></td>
			      </tr>
			      <tr class="fragment">
				<td><b>System F</b><br />(PFPL §16)</td>
				<td><i>System M plus</i> parametric polymorphic types</td>
			      </tr>
			      <tr class="fragment">
				<td><b>System FE</b><br />(PFPL §17)</td>
				<td><i>System F plus</i> existentially-quantified types</td>
			      </tr>
			      <tr class="fragment">
				<td><b>System F<sub>ω</sub></b><br />(PFPL §18)</td>
				<td><i>System FE plus</i> universally-quantified types</td>
			      </tr>
			    </table>
			  </section>

			  <section>
			    <h3>What We Gain</h3>

			    <p class="fragment">With each refinement, we:</p>

			    <p class="fragment">Increase generality</p>
			    <p class="fragment">Reduce type-specific syntax</p>
			    <p class="fragment">Increase expressive power</p>
			  </section>

			  <section>
			    <h3>However, Something's Missing...</h3>

			    <p class="fragment">System F<sub>ω</sub>
			    is reasonably expressive, but limited and
			    cumbersome:</p>

			    <ul>
			      <li class="fragment">
				Total languages are not universal<br />
				<span style="font-size: 75% ;
				font-style: italic">Cannot interpret a
				total language in itself, which would
				require solving the Halting
				Problem</span>
			      </li>
			      <li class="fragment">
				Programs encode their termination proofs<br />
				<span style="font-size: 75% ;
				font-style: italic">Via the inductive
				definition of natural numbers, on
				which these languages are based</span>
			      </li>
			    </ul>
			  </section>

			  <section>
			    <h3>Enter PCF</h3>

			    <p style="font-style: italic ; font-size:
			    50%"><a href="http://homepages.inf.ed.ac.uk/gdp/publications/LCF.pdf">Plotkin,
			    1977</a> | PFPL §19</p>

			    <p class="fragment">System F<sub>ω</sub>
			      plus <i>general recursion</i> via <i>partial functions</i> and 
			      <i>fixed-point operator</i></p>

			    <p class="fragment">Programs remain
			    well-typed, but may not terminate</p>

			    <p class="fragment">Lazy vs. eager
			    dynamics become subtle because
			    sub-computations may diverge</p>

			    <p class="fragment">PCF inspired ML and Haskell</p>
			  </section>

			  <section>
			    <h3>Recursive Evolution</h3>

			    <p class="fragment">We've relied thus far
			      on <i>primitive recursion</i>:</p>

			    <ul>
			      <li class="fragment">System
				  T's <code>rec()</code> construct
				  (PFPL §9)</li>
			      <li class="fragment">Iconic example
			      functions: addition, multiplication,
			      factorial</li>
			    </ul>
			  </section>

			  <section>
			    <h3>Recursive Evolution</h3>

			    <p class="fragment">We define <i>general
				recursion</i> via the <i>fixed-point operator</i>:</p>

			    <ul>
			      <li class="fragment">"Partial functions"
			      are those that may diverge for some or
			      all inputs</li>
			      <li class="fragment">"A fixed point of a
			      function is a value that, when applied
			      as the input of the function, returns
			      the same value as its
			      output." <span style="font-size: 50% ;
			      font-style:
			      italic">(<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Wikipedia</a>)</span></li>
			      <li class="fragment"></li>
			    </ul>
			  </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
